/* 
 * $Revision: 1.1 $  $Date: 2000/03/16 20:36:58 $ 
 */
/*
 * Copyright (c) 1984-1998 by The MathWorks, Inc.
 * All Rights Reserved.
 */

target="C";
include="libmatlbmx.h";  /* in same directory as libmatlbmx.mlib */
timestamp="Tue Feb 15 07:48:13 EST 2000";

deblank{
  nin    = 1;       /* number of M inputs */
  nout   = 1;       /* number of M outputs */
  scope  = global;
  cname  = mlfDeblank;   /* mxArray in and out */
  nargin = 0;       /* nargin  not used */
  nargout= 0;       /* nargout not used */
  reqin  = 1;       /* minimum number of inputs */
  reqout = 1;       /* minimum number of outputs */
}

intersect{
  nin    = 3;       /* number of M inputs */
  nout   = 3;       /* number of M outputs */
  scope  = global;
  cname  = mlfIntersect;   /* mxArray in and out */
  cname  = mlfNintersect;   /* used nargout */
  cname  = mlfVintersect;   /* output ignored */
  nargin = 0;       /* nargin  not used */
  nargout= 1;       /* nargout used */
  reqin  = 1;       /* minimum number of inputs */
  reqout = 1;       /* minimum number of outputs */
}

ismember{
  nin    = 3;       /* number of M inputs */
  nout   = 1;       /* number of M outputs */
  scope  = global;
  cname  = mlfIsmember;   /* mxArray in and out */
  nargin = 0;       /* nargin  not used */
  nargout= 0;       /* nargout not used */
  reqin  = 1;       /* minimum number of inputs */
  reqout = 1;       /* minimum number of outputs */
}

setdiff{
  nin    = 3;       /* number of M inputs */
  nout   = 2;       /* number of M outputs */
  scope  = global;
  cname  = mlfSetdiff;   /* mxArray in and out */
  nargin = 0;       /* nargin  not used */
  nargout= 0;       /* nargout not used */
  reqin  = 1;       /* minimum number of inputs */
  reqout = 1;       /* minimum number of outputs */
}

setxor{
  nin    = 3;       /* number of M inputs */
  nout   = 3;       /* number of M outputs */
  scope  = global;
  cname  = mlfSetxor;   /* mxArray in and out */
  cname  = mlfNsetxor;   /* used nargout */
  cname  = mlfVsetxor;   /* output ignored */
  nargin = 0;       /* nargin  not used */
  nargout= 1;       /* nargout used */
  reqin  = 1;       /* minimum number of inputs */
  reqout = 1;       /* minimum number of outputs */
}

strcat{
  nin    = 1;       /* number of M inputs */
  nout   = 1;       /* number of M outputs */
  scope  = global;
  varargin;         /* vargin used */
  cname  = mlfStrcat;   /* mxArray in and out */
  nargin = 0;       /* nargin  not used */
  nargout= 0;       /* nargout not used */
  reqin  = 1;       /* minimum number of inputs */
  reqout = 1;       /* minimum number of outputs */
}

strmatch{
  nin    = 3;       /* number of M inputs */
  nout   = 1;       /* number of M outputs */
  scope  = global;
  cname  = mlfStrmatch;   /* mxArray in and out */
  nargin = 0;       /* nargin  not used */
  nargout= 0;       /* nargout not used */
  reqin  = 1;       /* minimum number of inputs */
  reqout = 1;       /* minimum number of outputs */
}

union{
  nin    = 3;       /* number of M inputs */
  nout   = 3;       /* number of M outputs */
  scope  = global;
  cname  = mlfUnion;   /* mxArray in and out */
  cname  = mlfNunion;   /* used nargout */
  cname  = mlfVunion;   /* output ignored */
  nargin = 0;       /* nargin  not used */
  nargout= 1;       /* nargout used */
  reqin  = 1;       /* minimum number of inputs */
  reqout = 1;       /* minimum number of outputs */
}

unique{
  nin    = 2;       /* number of M inputs */
  nout   = 3;       /* number of M outputs */
  scope  = global;
  cname  = mlfUnique;   /* mxArray in and out */
  cname  = mlfNunique;   /* used nargout */
  cname  = mlfVunique;   /* output ignored */
  nargin = 0;       /* nargin  not used */
  nargout= 1;       /* nargout used */
  reqin  = 1;       /* minimum number of inputs */
  reqout = 1;       /* minimum number of outputs */
}
